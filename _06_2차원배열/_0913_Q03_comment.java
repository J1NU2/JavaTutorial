package _06_2차원배열;

public class _0913_Q03_comment {

	public static void main(String[] args) {
		int[][] a = new int[4][5];
		int num = 1;
		
		/* 다음 형태로 출력하기
		 * 1   2   3   4   5
		 * 10  9   8   7   6
		 * 11  12  13  14  15
		 * 20  19  18  17  16
		 */
		
		// 값을 저장하는 코드
		/* 문제 분석
		 *  0,0  0,1  0,2  0,3  0,4		행 고정 0 / 열 0 1 2 3 4
		 *  1,4  1,3  1,2  1,1  1,0     행 고정 1 / 열 4 3 2 1 0
		 *  2,0  2,1  2,2  2,3  2,4		행 고정 2 / 열 0 1 2 3 4
		 *  3,4  3,3  3,2  3,1  3,0		행 고정 3 / 열 4 3 2 1 0
		 *  i를 행으로 보고, j를 열로 본다.
		 *  행이 짝수일 때는 열이 0 1 2 3 4 형태로 변화한다.
		 *  행이 홀수일 때는 열이 4 3 2 1 0 형태로 변화한다.
		 *  짝수일 경우와 홀수일 경우의 조건식을 작성하면 되는 것을 알 수 있다.
		 *  System.out.println(i + "," + j);
		 */
		for (int i=0; i<4; i++) {
			// System.out.println("현재 행 : " + i);
			if ((i % 2) == 1) {		// 행이 홀수일 경우
				for (int j=4; j>=0; j--) {
					// System.out.println(i + "," + j);
					a[i][j] = num++;
				}
			} else {				// 행이 짝수일 경우
				for (int j=0; j<5; j++) {
					// System.out.println(i + "," + j);
					a[i][j] = num++;
				}
			}
		}
		
		/* 위에서 사용한 코드 a[i][j] = num++; =(동일하다)= a[i][j]=num; num++;
		 * 1) 만약 a = num++ 형태라면..
		 * 대입 연산자인 =가 먼저 실행되고 단일 연산자인 ++이 실행된다.
		 * 2) 만약 a = ++num 형태라면..
		 * 단일 연산자인 ++이 먼저 실행되고 대입 연산자인 =가 실행된다.
		 * 1번 케이스를 후위 단일 연산자라고 하며, 2번 케이스를 전위 단일 연산자라고 한다.
		 * ... 아마 단일 연산자가 앞에 있는가, 뒤에 있는가의 차이에 따라 달라지는 것 같다.
		 */
		
		// 출력을 위한 코드
		for (int i=0; i<4; i++) {
			for (int j=0; j<5; j++) {
				System.out.print(a[i][j] + " ");
			}
			System.out.println();
		}
	}
}
